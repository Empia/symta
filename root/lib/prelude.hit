use prelude_base

with Args Fn => [Fn @Args]

fn_of X What => 'bool' is What
integer_of X What => 'integer' is What
text_of X What => 'text' is What
list_of X What => 'list' is What

lists_eq A B => if A end or B end then A end and B end
                else if A.head is B.head then lists_eq A.tail B.tail
                else No
list_is A B => if B of list then lists_eq A B
               else No

generic_size2 S Xs => if Xs end then S
                      else generic_size2 S+1 Xs.tail
generic_size Xs => generic_size2 0 Xs
generic_isnt O X => not: O is X

/*
list_get2 Xs N I => if I is N then Xs.head
                    else list_get2 Xs.tail N I+1
list_get Xs N => list_get2 Xs N 0

reverse2 Xs Ys => if Xs end then Ys
                  else reverse2 Xs.tail (Ys headed Xs.head)
list_reverse Xs => reverse Xs []
*/

generic_map Xs F => if Xs end then Xs
                    else (generic_map Xs.tail F) headed (F Xs.head)


list_take2 Xs N I Ys => if I is N then Ys
                        else list_take2 Xs.tail N I+1 (Ys headed Xs.head)
list_take Xs N => if N < 0
                  then list_take2 Xs.reverse N.neg 0 []
                  else (list_take2 Xs N 0 []) reverse

list_drop2 Xs N I => if I is N then Xs else list_drop2 Xs.tail N I+1
list_drop Xs N => if N < 0
                  then (list_drop2 Xs.reverse N.neg 0).reverse
                  else list_drop2 Xs N 0

generic_head O => O get 0
generic_tail O => O drop 1
generic_last O => O get: O.size - 1
generic_lead O => O take: O.size - 1

list_before Xs X => [@Xs X]
list_mix A B => [@A @B]



list_each Xs F => if Xs end then
                  else | F Xs.head
                       | list_each Xs.tail F

text_chars2 Xs I Ys => if I is -1 then Ys
                       else text_chars2 Xs I-1 (Ys headed Xs.I)
text_chars Xs => text_chars2 Xs Xs.size-1 []
text_map Xs F => Xs.chars map F

text_each2 Xs S I F => if I is S then
                       else | F Xs.I
                            | text_each2 Xs S I+1 F
text_each Xs F => text_each2 Xs Xs.size 0 F

text_mix A B => [A B] join_text
text_reverse Xs => Xs.chars.reverse.join_text
text_take Xs N => (Xs.chars take N).reverse.join_text
text_drop Xs N => (Xs.chars drop N).reverse.join_text

has N Xs F => if Xs end then No
              else if F Xs.head then N
              else has N+1 Xs.tail F
generic_has Xs F => has 0 Xs F
text_has Xs F => Xs.chars has F

sym_head? C => if C alpha? then Yes
               else ['_' '?' '<' '>'] has: X => X is C
sym_body? C => if C digit? then Yes else sym_head? C

//temporary hack; because Yes/No/Void should be functions
fn_asText O => if Yes is O then 'Yes'
               else if No is O then 'No'
               else if Void is O then 'Void'
               else '#invalid'

Keywords = list 'Yes' 'No' 'Void' 'and' 'or' 'if' 'then' 'else'

text_asText O =>
  if O is '' then '``'
  else if Keywords has: K => K is O then ['`' O '`'] join_text
  else | Q = if not (sym_head? O.0) then '`'
             else if O has: X => not sym_body?.X then '`'
             else '' //no need for quotes
       | Xs = O map: C => if C is Q then '\\`' //quote
                          else if C is '\n' then '\\n'
                          else C
       | [Q @Xs Q] join_text

// intersperse Xs with M
// infix 'and' [cat dog fox] --> [cat and dog and fox]
infix M Xs => if Xs end then []
              else | T = Xs tail
                   | if T end then Xs
                     else ((infix M T) headed M) headed Xs.head

list_asText O =>
  | S = O size
  | if (if S is 2 then
          if O.0 is '\\' then Yes
          else No
        else No)
    then break list_asText (['\\' (asText O.1)] join_text)
    else Void
  | Max = 150
  | Xs = O take (if S < Max then S else Max)
  | Xs = infix ' ': Xs map: X => asText X
  | E = if S < Max then [] else [' ...']
  | ['(' @Xs @E ')'] join_text

printable? X => if tag_of.X isnt fn then Yes
                else if [Yes No Void] has:S => S is X then Yes
                else tag_of.X is printable

asText X => if printable? X then X asText
            else [`#[` address_of.X.asText `]`] join_text

say @Xs => | Xs = infix ' ': Xs map: X => if tag_of.X is text then X else asText X
           | text_out [@Xs '\n'].join_text

bad @What => | say bad @What
             | halt

export '+' '-' '*' '/' '%' '=>' ':' ';' //re-export
       'with'
       fn_of integer_of text_of list_of
       generic_has infix list_asText
       text_chars text_reverse text_mix text_take text_drop text_asText
       say bad
