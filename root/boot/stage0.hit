// this stage sets up macro expander and a few vital utilities

/* Quick Reference of Builtins:
(_fn Args @Body) makes a anonymous lambda function
(_fn Args (_tag Tag) @Body) like above, but with Tag, retrievable by tag_of
(_if Test Then Else) if/then/else conditional
(_quote Expression) escapes expression from evaluation
(_set Argument Value) assigns Value to Argument, previously introduced by _fn
(_goto Label) transfers control to a label inside of _fn Body
*/

(_fn (list `[]` list_is list_map list_size list_find list_reverse list_reverse2
      list_get list_get2 list_last list_last2
      not error builtin? integer_digits integer_digits2 integer_asText run_stage headed? fn? Vars
      Macs GensymCount text_gensym get_macro applyMacro add_macro macroexpands?
      load_text_file expandAll expandFn expandFn2 expand expandBuiltin expandNormal expandNormal2
      macroexpand)
  (_set list (_fn (@Xs) Xs))
  (_set `[]` &list)
  (_set not (_fn (X) (_if X No Yes)))
  (_set error (_fn (@Xs)
               (_if (Xs end)
                    (halt)
                    ((_fn (A B) (error @(Xs tail)))
                     (text_out (Xs head))
                     (text_out ` `)))))
  (set_error_handler &error)
  (_set list_is (_fn (A B) No))
  (_set list_map
        (_fn (Xs F)
          (_if (Xs end)
               Xs
               ((_fn (X) ((list_map (Xs tail) F) headed X))
                (F (Xs head))))))
  (_set list_size
        (_fn (Xs)
           (_if (Xs end)
                0
                (1 `+` (list_size (Xs tail))))))
  (_set list_get2
        (_fn (Xs N I)
           (_if (I is N)
                (Xs head)
                (list_get2 (Xs tail) N (I `+` 1)))))
  (_set list_get (_fn (Xs N) (list_get2 Xs N 0)))
  (_set list_last2
        (_fn (H Xs)
           (_if (Xs end)
                (H head)
                (list_last2 Xs (Xs tail)))))
  (_set list_last
        (_fn (Xs)
           (_if (Xs end)
                (error last on empty list)
                (list_last2 Xs (Xs tail)))))
  (_set list_find 
        (_fn (Xs F)
          (_if (Xs end)
               No
               (_if (F (Xs head))
                    (Xs head)
                    (list_find (Xs tail) F)))))
  (_set list_reverse2
        (_fn (Xs Ys)
           (_if (Xs end) Ys (list_reverse2 (Xs tail) (Ys headed (Xs head))))))
  (_set list_reverse (_fn (Xs) (list_reverse2 Xs [])))
  (_set integer_digits2
        (_fn (Ds N)
          (_set Ds [(N `%` 10) @Ds])
          (_set N (N `/` 10))
          (_if (N > 0) (integer_digits2 Ds N) Ds)))
  (_set integer_digits (_fn (N) (integer_digits2 [] N)))
  (_set integer_asText
        (_fn (O)
          ([(_if (O < 0) `-` ``)
            @(((_if (O < 0) (O neg) O) digits)
               map (_fn (D) ((_quote `0123456789`) D)))
            ] join_text)))
  (_set GensymCount 0)
  (_set text_gensym
        (_fn (X)
          (_set GensymCount (GensymCount `+` 1))
          ([X (GensymCount asText) `&`] join_text)))
  (_set headed?
        (_fn (X Xs)
          (_if ((tag_of Xs) is list)
               (_if (Xs end)
                    No
                    ((Xs head) is X))
               No)))
  (_set fn? (_fn (Xs) (headed? _fn Xs)))
  (_set builtin?
        (_fn (Xs)
          (_if ((tag_of Xs) is text)
               (_if ((Xs size) > 0)
                    (_if ((Xs 0) is _)
                         Yes
                         No)
                    No)
               No)))
  (_set Vars (list))
  (_set Macs (list))
  (_set get_macro
        (_fn (N)
          (_if ((tag_of N) is macro)
               N
               ((_fn (M) (_if M (M 1) No))
                (Macs find (_fn (X) ((X head) is N)))))))
  (_set macroexpands? (_fn (X) (_if (get_macro X) Yes No)))
  (_set applyMacro
        (_fn (F As success fail)
          ((_fn (M)
             (_if ((tag_of M) is macro)
                  (success ((M value) @As))
                  (fail)))
           (get_macro F))))
  (_set load_text_file (_fn (Name) (utf8_to_text (load_file Name))))
  (_set expandAll (_fn (Xs) (Xs map &expand)))
  (_set expandFn2
         (_fn (OVars As Xs)
           (_set Vars (Vars headed As))
           (_set Xs (expandAll Xs))
           (_set Vars OVars)
           Xs))
  (_set expandFn
         (_fn (Tag As Xs)
           (_if ((tag_of As) is list)
                 (_if Tag
                      [Tag As @(expandFn2 Vars As Xs)]
                      [As @(expandFn2 Vars As Xs)])
                 (expandFn As (Xs head) (Xs tail)))))
  (_set expand
        (_fn (E)
          (_if ((tag_of E) is list)
               (_if (E end)
                    E
                    ((_fn (Head Tail)
                        (_if (builtin? Head)
                             (expandBuiltin Head Tail E)
                             (expandNormal Head Tail)))
                     (E head) (E tail)))
                 E)))
  (_set expandBuiltin
         (_fn (X Xs Base)
           (_if (X is _fn) [X @(expandFn No (Xs head) (Xs tail))]
           (_if (X is _if) (expandAll Base)
           (_if (X is _quote) Base
           (_if (X is _set) (expandAll Base)
           (_if (X is _goto) (expandAll Base)
           (_if (X is _show) (expandAll Base)
           (_if (X is _tag) Base
           (error invalid builtin X)
           )))))))))
  (_set expandNormal2
         (_fn (F As)
           ((_fn (M)
              (_if ((tag_of M) is macro)
                   (expand ((M value) @As))
                   [F @(expandAll As)]))
            (get_macro F))))
  (_set expandNormal
         (_fn (F As)
           (_if (fn? F) //expand args before body
               ((_fn (As) [(expand F) @As]) (expandAll As))
               (applyMacro F As
                 &expand
                 (_fn ()
                   ((_fn (F)
                     (_if ((tag_of F) is list)
                          (applyMacro (F head) (F tail)
                            (_fn (F) (expand [F @As]))
                            (_fn () [F @(expandAll As)]))
                          [F @(expandAll As)]))
                    (expand F)))))))
  (_set macroexpand
    (_fn (Expr NewMacs)
      ((_fn (OldMacs R)
        (_set Macs (NewMacs reverse)) //reverse to allow overriding
        (_set R (expand Expr))
        (_set Macs OldMacs)
        R)
       Macs Void)))
  (_set add_macro (_fn (Name Macro) (_set Macs [[Name (_fn (X) (_tag macro) Macro)] @Macs])))
  (_set run_stage
    (_fn (Name Macs @Env)
        ((macroexpand ((load_text_file Name) parse Name) Macs)
         eval [[(_quote `Env`) Env] [(_quote `Macs`) Macs] @Env])))
  (add_macro progn
    (_fn (@Xs)
      ((_fn (As) [[_fn As (_if As (As last) Void)] [`@` [list @Xs]]])
       (Xs map (_fn (X) ((_quote A) gensym))))))
  (add_macro let
   (_fn (Bs @Xs)
      [[_fn (Bs map (_fn (B) (_if ((tag_of B) is text) B (B head)))) @Xs]
       [`@` [list @(Bs map (_fn (B) (_if ((tag_of B) is text) Void (B 1))))]]]))
  (add_macro pop
   (_fn (Xs)
    ((_fn (X)
       [[_fn [X] [_set Xs [Xs tail]] X] [Xs head]])
     ((_quote A) gensym))))
  (add_macro `if` (_fn (A B C) [_if A B C]))
  (add_macro `.` (_fn (A B) [A B]))
  (add_macro `~` (_fn (A B) [B A]))
  (add_macro `\\` (_fn (X) [_quote X]))
  (run_stage `boot/stage1.hit` Macs
    [`[]` &`[]`]
    [list &list]
    [not &not]
    [error &error]
    [list_is &list_is]
    [list_map &list_map]
    [list_size &list_size]
    [list_last &list_last]
    [list_reverse &list_reverse]
    [integer_digits &integer_digits]
    [integer_asText &integer_asText]
    [text_gensym &text_gensym]
    [load_text_file &load_text_file]
    [headed? &headed?]
    [list_get &list_get]
    [macroexpand &macroexpand]
    [macroexpands? &macroexpands?]
    @Env)
 ) No No No No No No No No No No No No No No No No No No No
   No No No No No No No No No No No No No No No No No No No
