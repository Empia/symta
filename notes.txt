NOTES:
01-09-2014: GC lifting can be optimized by avoiding duplicates in the lift-list. That can be implemented by marking lifted cells, during lift-proccess.
30-06-2014: Treating list of a single element as the element itself breaks strong typing and makes a lot of tasks unncesessary hard. For example, a function declaration (define (f) 123) becomes indiscernible from (define f 123) - a variable declaration
30-06-2014: The idea of treating an integer N as a list of [1 2 3 ... N] leads to a problem with pattern matching, where [a b [1 2 3] c] is indiscernible from [a b 3 c]. Other subtler and dangerous problems can be observed: for example, strong typing stops working and a huge class of errors won't be catched and logged.
11-06-2014: Assigning a value to a location above it requires GC to lift assigned value to the level of its new holder. First it must be determined if the assigned value is below the place it gets assigned to (can be implemented by storing level inside of a pointer). Then the value could be lifted there with help of GC. To do that, the "lift" list must introduced - this list will hold addresses of old cells, which reference young values. During GC, that list gets iterated, values lifted into the frame above, cells get updated with new references, and removed from the lift, if referenced values attain the same height as the referencing cells. The lift list could be stored near the Base. Naive implementation could leak memory if cell gets reassigned, but that could be solved by more sophisticated implementation or by forcing a GC from time to time.
09-06-2014: Forcing GC on a specific stack frame requires knowing all temporary variables, meaning that C/C++ stack can't be reused, so Symta's own stack have to be introduced; To do that, temporaries must be hoisted to the topmost _progn of the current _fn.
09-06-2014: Passthrough builtins, like `log` and `{!}`, may mess up FLIP_HEAP, if they won't copy passed value by means of RETURN(value).
