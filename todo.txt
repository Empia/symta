- `!I+1`, while more flexible, is really clunky construct, inferior to I++, because it requires holding shift and pressing different keys.  The `++` and `--` are already used, so we have to remap them to ^+ and ^-. Bitwise-AND should be remapped to ^*, because AND has many properties of multiplications. Same way ^< and ^> will look nice as bitwise shifts. These are defined runtime.c, reader.s and macro.s
    `^^` A B = [_mcall A '^^' B]
    `--` A B = [_mcall A '--' B]
    `++` A B = [_mcall A '++' B]
    `</` A B = [_mcall A '</' B]
    `/>` A B = [_mcall A '/>' B]
  ^^ = *, (bitwise and)
  -- = +, (bitwise eXclusive or XOR)
  ++ = -, (bitwise inclusive or)
  </ = <, (shift left)
  /> = >, (shift right)
  (A.m<,N.a)*,Mask*,Gold
- Consider using `++` and `--` to advance view (by modifying it, instead of creating new one). That way code using C++ pointers inside of array can be translated to Symta without that much fuzz.
- Consider using  `*` to access the head element: *Xs would be the same as Xs.head or Xs.0. Currently *Xs is unused. Xs.0 and Xs.head are used 180 times in Spell of Mastery. Stuff like  `Xs.(Ys.0)` could be rewritten to `Xs.*Ys`. Note: watch for `**` used as multiplication, rename it to `^^`.
- `pop` is relatively inefficient, so should be replaced by pointer
- `done` and `pass` for `dup` and `map` macros, where these keyword will yield alternative value or skip value.
- recompile dependent modules only when exports list changes
- Proper file interface with catching, representing files as usual lists:
  file{Name}.utf8
  file{Name}.get{Offset Length}
  file{Name}.list
  file{Name}.Offset <= Byte
- types should allow keywords initing fields by default; rethink the whole keywords syntax; because lowercase letter type constructor already conflicts with lowercase letter in function calls. I.e. make keywords to be uppercase
- proper documentation for non-local return
- Array slicing (could be implemented through a{} calling different method when used with `:`). Currently SoM has 192:28 proportion of List.Index to List.(expr). Consider Python's approach
  a[start:end] # items start through end-1
  a[start:]    # items start through the rest of the array
  a[:end]      # items from the beginning through end-1
  a[:]         # a copy of the whole array
  a[start:end:step] # step through array (usable with any of the above)
  a[-1]    # last item in the array
  a[-2:]   # last two items in the array
  a[:-2]   # everything except the last two items
- optimize `ssa losure`, which is not required in most cases.
- More-efficient hash tables, because K.hash%Bs.size is known to be arithmetic expression
- `:` should work inside of `{}`
- "case C" and `when C` should require `:`, otherwise it is too confusing.
  Alternatively `and` and `or` should have usual binary op syntax, otherwise they are too confusing
- Move all these "static uint8_t b__16335[]" into separately loadable string table to speedup compilation
  That will also make it possible to localize the application, without recompiling it.
- fast arithmetics, when all arithmetic operands being checked for FIXNUM at call site
- inline insertion of C/C++-style code, interfacing with FFI, which in the end could be used to reimplement runtime.c
- a way to quickly set all object fields to 0
- a way to disable CHECK_NARGS for production code
- expand_match should not do is_list, when called fron lambda arglist matching, as it is known to be is_list
- messages like `couldnt match args list`, should be part of runtime, or maybe _core
- Interpreter. Especially useful when C compiler is unavailable for bootstrap and for scripting.
- SYMTA_DEBUG should be define by compiler, based on command line options; watch for already compiled dependencies. Everything should be recompiled from scratch, when such option changes.
  - missing meta info for some symbols:
  0000000064799369:unnamed:502,23,C:/Users/nikita/Documents/git/symta/src/compiler.s
  0000000065CC3EC2:hard_list.map:0,0,unknown
  0000000065CDA031:_.{}:0,0,unknown
  0000000064790C45:produce_ssa:502,23,C:/Users/nikita/Documents/git/symta/src/compiler.s
- api->method could probably be replaced with get_meta
- make method tables sparse to reduce memory overhead: instead of NTypes*NMethods table, cache most recent types->methods at the call place.
- when jumps goes over variable introduction, notify user
- array fields should provide special `!`, which uses init, instead of allocating new memory.
- list of all functions that use specific function
- unless export table changes, no recompilation of dependent files should be required
- a way to simply include other symta file directly, as part of macro facility. I.e. `include` should be macro
- better way to read items from byte arrays. Also consider bit arrays
- symbols starting with digit, like `4players`, should be printed with "``" quotes
- tab character in text breaks parser
- `when 123: 456;` gives parser error "bad call: () `.` 0", under parse_semicolon
- `when got!it Expr: process it` should work with if
- confusing and non uniform absence of  `:` in `when Condition | action`
- rename `leave` to `lift, that is shorter and better describes what is being done to value. We are lifting control and result value back to the caller.
- unknown variable at top level doesn't provide location, just "unknown:0,0: undefined variable `XYZ`"
- a way to declare argument type for fast field access and to avoid `Me=type` comments
- Source location in stack traces. So when a wrong method on `No` object gets called, we can get the location immediately.
- proper heap allocation, instead of enheap, allowing moving any type to heap.
- enheap related stuff should be part of runtime to maximize efficiency
- the `_.enheap` returns base type, instead of returning derived type object; provide a way to access complete object inside called method
- Dynamic malloc and free, when say "P = freeable: point X Y" allocates point inside of inside of user provided pool. There should be an easy way to move existing object into pool and from pool.
- proper I/O streams, so that output of underlying could be redirected or suppressed.
- Networking
- some potential problems with class inheritance, like no base class data fields: adding `items` field in widget leads to subtle error
- variables are exported by value, instead of by reference, so they cannot be modified
